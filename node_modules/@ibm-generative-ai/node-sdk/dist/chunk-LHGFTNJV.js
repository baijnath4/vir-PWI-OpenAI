var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/api-types.ts
var api_types_exports = {};
__export(api_types_exports, {
  ChatInputSchema: () => ChatInputSchema,
  ChatOutputSchema: () => ChatOutputSchema,
  ChatRoleSchema: () => ChatRoleSchema,
  ChatStreamInputSchema: () => ChatStreamInputSchema,
  ChatStreamOutputSchema: () => ChatStreamOutputSchema,
  FileCreateInputSchema: () => FileCreateInputSchema,
  FileInputSchema: () => FileInputSchema,
  FileOutputSchema: () => FileOutputSchema,
  FilePurposeSchema: () => FilePurposeSchema,
  FilesOutputSchema: () => FilesOutputSchema,
  GenerateConfigInputSchema: () => GenerateConfigInputSchema,
  GenerateConfigOutputSchema: () => GenerateConfigOutputSchema,
  GenerateInputSchema: () => GenerateInputSchema,
  GenerateLimitsOutputSchema: () => GenerateLimitsOutputSchema,
  GenerateOutputSchema: () => GenerateOutputSchema,
  GenerateResultSchema: () => GenerateResultSchema,
  GenerateStopReasonSchema: () => GenerateStopReasonSchema,
  HistoryInputSchema: () => HistoryInputSchema,
  HistoryOriginSchema: () => HistoryOriginSchema,
  HistoryOutputSchema: () => HistoryOutputSchema,
  HistoryStatusSchema: () => HistoryStatusSchema,
  ModelOutputSchema: () => ModelOutputSchema,
  ModelsOutputSchema: () => ModelsOutputSchema,
  PromptTemplateCreateInputSchema: () => PromptTemplateCreateInputSchema,
  PromptTemplateExecuteInputSchema: () => PromptTemplateExecuteInputSchema,
  PromptTemplateExecuteOutputSchema: () => PromptTemplateExecuteOutputSchema,
  PromptTemplateInputSchema: () => PromptTemplateInputSchema,
  PromptTemplateOutputSchema: () => PromptTemplateOutputSchema,
  PromptTemplateUpdateInputSchema: () => PromptTemplateUpdateInputSchema,
  PromptTemplatesOutputSchema: () => PromptTemplatesOutputSchema,
  TokenizeInputSchema: () => TokenizeInputSchema,
  TokenizeOutputSchema: () => TokenizeOutputSchema,
  TuneInputSchema: () => TuneInputSchema,
  TuneMethodsOutputSchema: () => TuneMethodsOutputSchema,
  TuneOutputSchema: () => TuneOutputSchema,
  TuneStatusSchema: () => TuneStatusSchema,
  UserGenerateDefaultInputSchema: () => UserGenerateDefaultInputSchema
});
import { z } from "zod";
var PaginationOutputSchema = z.object({
  totalCount: z.number().int().nonnegative(),
  results: z.array(z.any())
});
var UserGenerateDefaultInputSchema = z.object({
  model_id: z.string(),
  parameters: z.optional(z.record(z.any()))
});
var ParametersSchema = z.record(z.any());
var GenerateInputSchema = z.object({
  model_id: z.string().nullish(),
  prompt_id: z.string().nullish(),
  inputs: z.array(z.string()),
  parameters: z.optional(ParametersSchema),
  use_default: z.optional(z.boolean())
});
var GenerateStopReasonSchema = z.enum([
  "NOT_FINISHED",
  "MAX_TOKENS",
  "EOS_TOKEN",
  "CANCELLED",
  "TIME_LIMIT",
  "STOP_SEQUENCE",
  "TOKEN_LIMIT",
  "ERROR"
]);
var GenerateModerationSchema = z.object({
  hap: z.optional(
    z.array(
      z.object({
        success: z.boolean(),
        flagged: z.boolean(),
        score: z.number().min(0).max(1),
        position: z.object({
          start: z.number().int().min(0),
          stop: z.number().int().min(0)
        })
      }).passthrough()
    )
  )
}).passthrough();
var GenerateResultSchema = z.object({
  generated_text: z.string(),
  generated_token_count: z.number().int().min(0),
  input_token_count: z.number().int().min(0),
  stop_reason: GenerateStopReasonSchema
}).passthrough();
var GenerateOutputSchema = z.object({
  model_id: z.string(),
  created_at: z.coerce.date(),
  results: z.array(GenerateResultSchema),
  moderation: GenerateModerationSchema.optional()
}).passthrough();
var GenerateLimitsOutputSchema = z.object({
  tokenCapacity: z.number().int().nonnegative(),
  tokensUsed: z.number().int().nonnegative()
});
var GenerateConfigInputSchema = z.object({
  model_id: z.optional(z.string()),
  parameters: z.optional(z.record(z.any()))
});
var GenerateConfigOutputSchema = z.object({
  model_id: z.string().nullish(),
  parameters: z.record(z.any()).nullish()
});
var TokenizeInputSchema = z.object({
  model_id: z.string().nullish(),
  inputs: z.array(z.string()),
  use_default: z.optional(z.boolean()),
  parameters: z.optional(z.object({ return_tokens: z.optional(z.boolean()) }))
});
var TokenizeOutputSchema = z.object({
  model_id: z.string(),
  created_at: z.string(),
  results: z.array(
    z.object({
      token_count: z.number().int().nonnegative(),
      tokens: z.array(z.string())
    })
  )
});
var ModelsOutputSchema = z.object({
  results: z.array(
    z.object({
      id: z.string(),
      name: z.string(),
      size: z.string(),
      token_limit: z.number().int().nonnegative()
    })
  )
});
var ModelSchemaSchema = z.object({ id: z.number().int(), value: z.any() });
var ModelOutputSchema = z.object({
  results: z.object({
    id: z.string(),
    name: z.string(),
    size: z.string(),
    description: z.string(),
    token_limit: z.number().int().nonnegative(),
    tags: z.array(z.string()),
    source_model_id: z.string().nullable(),
    tasks: z.array(
      z.object({
        id: z.string(),
        name: z.string(),
        json_example: z.string(),
        jsonl_example: z.string()
      })
    ),
    model_family: z.object({
      id: z.number().int(),
      name: z.string(),
      short_description: z.string().nullish(),
      description: z.string().nullish()
    }),
    schema_generate: ModelSchemaSchema,
    schema_tokenize: ModelSchemaSchema
  })
});
var TuneStatusSchema = z.enum([
  "INITIALIZING",
  "NOT_STARTED",
  "PENDING",
  "HALTED",
  "RUNNING",
  "QUEUED",
  "COMPLETED",
  "FAILED"
]);
var TuneFileSchema = z.object({
  id: z.string(),
  file_name: z.string(),
  created_at: z.string()
});
var TuneMixinSchema = z.object({
  id: z.string(),
  name: z.string(),
  model_id: z.string(),
  method_id: z.string(),
  model_name: z.string(),
  status: TuneStatusSchema,
  task_id: z.string(),
  parameters: z.object({
    batch_size: z.number().int().positive(),
    num_epochs: z.number().int().positive()
  }),
  created_at: z.string()
});
var TuneInputSchema = z.object({
  name: z.string(),
  model_id: z.string(),
  task_id: z.string(),
  training_file_ids: z.array(z.string()),
  validation_file_ids: z.array(z.string()).nullish(),
  evaluation_file_ids: z.array(z.string()).nullish(),
  method_id: z.string(),
  parameters: z.record(z.any()).nullish()
});
var TuneOutputSchema = z.object({
  results: TuneMixinSchema.extend({
    validation_files: z.array(TuneFileSchema).nullish(),
    training_files: z.array(TuneFileSchema).nullish(),
    evaluation_files: z.array(TuneFileSchema).nullish(),
    datapoints: z.object({
      loss: z.array(
        z.object({
          data: z.any(),
          timestamp: z.string()
        })
      )
    }).nullish()
  })
});
var TuneMethodsOutputSchema = z.object({
  results: z.array(
    z.object({
      id: z.string(),
      name: z.string()
    })
  )
});
var PromptTemplateInputSchema = z.object({
  id: z.string()
}).strict();
var PromptTemplateCreateInputSchema = z.object({
  name: z.string(),
  value: z.string()
}).strict();
var PromptTemplateUpdateInputSchema = PromptTemplateCreateInputSchema;
var SinglePromptTemplateOutputSchema = z.object({
  id: z.string(),
  name: z.string(),
  value: z.string(),
  created_at: z.coerce.date()
}).passthrough();
var PromptTemplateOutputSchema = z.object({
  results: SinglePromptTemplateOutputSchema
});
var PromptTemplatesOutputSchema = PaginationOutputSchema.extend({
  results: z.array(SinglePromptTemplateOutputSchema)
}).passthrough();
var PromptTemplateExecuteInputSchema = z.object({
  inputs: z.array(z.string()),
  template: z.union([
    z.object({ id: z.string() }),
    z.object({
      value: z.string(),
      data: z.object({}).passthrough()
    })
  ])
});
var PromptTemplateExecuteOutputSchema = z.object({
  results: z.array(z.string())
});
var HistoryStatusSchema = z.enum(["SUCCESS", "ERROR"]);
var HistoryOriginSchema = z.enum(["API", "UI"]);
var HistoryInputSchema = z.object({
  status: HistoryStatusSchema,
  origin: HistoryOriginSchema
}).partial();
var HistoryOutputSchema = PaginationOutputSchema.extend({
  results: z.array(
    z.object({
      id: z.string(),
      duration: z.number().int().min(0),
      request: GenerateInputSchema.partial(),
      status: HistoryInputSchema.shape.status,
      created_at: z.coerce.date(),
      response: GenerateOutputSchema.nullable()
    }).passthrough()
  )
});
var FilePurposeSchema = z.enum(["tune", "template", "tune_import"]);
var FileInputSchema = z.object({
  id: z.string()
}).strict();
var FileCreateInputSchema = z.custom();
var SingleFileOutputSchema = z.object({
  id: z.string(),
  file_name: z.string(),
  purpose: FilePurposeSchema,
  created_at: z.coerce.date()
}).passthrough();
var FileOutputSchema = z.object({
  results: SingleFileOutputSchema
});
var FilesOutputSchema = PaginationOutputSchema.extend({
  results: z.array(SingleFileOutputSchema)
});
var ChatRoleSchema = z.enum(["user", "system", "assistant"]);
var ChatInputSchema = z.object({
  model_id: z.string(),
  messages: z.array(
    z.object({
      role: ChatRoleSchema,
      content: z.string()
    })
  ),
  conversation_id: z.string().nullish(),
  parent_id: z.string().nullish(),
  prompt_id: z.string().nullish(),
  parameters: ParametersSchema.nullish()
});
var ChatOutputSchema = z.object({
  conversation_id: z.string(),
  results: z.array(
    z.object({
      generated_text: z.string()
    }).partial()
  )
});
var ChatStreamInputSchema = ChatInputSchema;
var ChatStreamOutputSchema = ChatOutputSchema;

// src/errors.ts
import {
  AxiosHeaders,
  HttpStatusCode,
  isAxiosError,
  isCancel as isAxiosCancel
} from "axios";
var BaseError = class extends Error {
};
var InvalidInputError = class extends BaseError {
};
var InternalError = class extends BaseError {
};
var RequestError = class extends BaseError {
  code;
  cancelled;
  constructor(message, code, cancelled = false, options) {
    super(message, options);
    this.name = new.target.name;
    this.code = code;
    this.cancelled = cancelled;
    Object.setPrototypeOf(this, new.target.prototype);
    Error.captureStackTrace(this, this.constructor);
  }
};
var RequestCanceledError = class extends RequestError {
  constructor(message, code, options) {
    super(message, code, true, options);
  }
};
var HttpError = class extends RequestError {
  statusCode;
  extensions;
  response;
  headers;
  constructor(message, statusText, statusCode, extensions, response, headers, options) {
    super(message, "ERR_NON_2XX_3XX_RESPONSE", false, options);
    this.statusCode = statusCode;
    this.extensions = extensions;
    this.response = response;
    this.headers = headers;
  }
};
function isAbortError(err) {
  return Boolean(err && err instanceof Error && err.name === "AbortError");
}
function errorTransformer(err) {
  if (isAbortError(err)) {
    return new RequestCanceledError(
      err.message,
      String(err.cause ?? err.name),
      {
        cause: err
      }
    );
  }
  if (!isAxiosError(err)) {
    return err;
  }
  if (err.response) {
    const response = err.response;
    return new HttpError(
      response.data.message,
      response.statusText,
      response.status,
      response.data.extensions,
      response.data,
      response.headers instanceof AxiosHeaders ? response.headers.toJSON() : (
        // There's some inconsistency between node headers and axios headers types (and only types because we are not in the browser)
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        response.headers
      ),
      { cause: err }
    );
  }
  if (isAxiosCancel(err)) {
    return new RequestCanceledError(err.message, err.code, { cause: err });
  }
  return new RequestError(err.message, err.code, false, { cause: err });
}
function isRetrievableError(error) {
  if (error instanceof HttpError) {
    return [
      // Client errors
      HttpStatusCode.RequestTimeout,
      HttpStatusCode.TooManyRequests,
      // Server errors
      HttpStatusCode.InternalServerError,
      HttpStatusCode.BadGateway,
      HttpStatusCode.ServiceUnavailable,
      HttpStatusCode.GatewayTimeout,
      HttpStatusCode.InsufficientStorage
    ].includes(error.statusCode);
  }
  if (error instanceof RequestError) {
    return !error.cancelled;
  }
  return false;
}

// src/buildInfo.ts
var version = "1.5.0";

// src/constants.ts
var RETRY_ATTEMPTS_DEFAULT = 3;

// src/client/client.ts
import http from "http";
import https from "https";
import { Transform } from "stream";
import axios, { AxiosError } from "axios";
import FormData from "form-data";
import {
  setupCache
} from "axios-cache-interceptor";
import promiseRetry from "promise-retry";
import {
  EventStreamContentType,
  fetchEventSource
} from "@ai-zen/node-fetch-event-source";

// src/helpers/common.ts
import { callbackify } from "util";
import { URLSearchParams as URLSearchParams2 } from "url";
import { z as z2 } from "zod";
function isTruthy(value) {
  return Boolean(value);
}
function concatUnique(...arrays) {
  const merged = arrays.filter(isTruthy).flat();
  return Array.from(new Set(merged).values());
}
function isNotEmptyArray(arr) {
  return Array.isArray(arr) && arr.length > 0;
}
async function wait(ms) {
  await new Promise((resolve) => setTimeout(resolve, ms));
}
function isFunction(value) {
  return z2.function().safeParse(value).success;
}
function safeParseJson(value) {
  try {
    return JSON.parse(typeof value === "string" ? value : String(value));
  } catch {
    return null;
  }
}
function parseFunctionOverloads(inputOrOptionsOrCallback, optionsOrCallback, callback) {
  if (isFunction(inputOrOptionsOrCallback)) {
    return { callback: inputOrOptionsOrCallback };
  }
  const input = inputOrOptionsOrCallback;
  const options = isFunction(optionsOrCallback) ? void 0 : optionsOrCallback;
  const cb = isFunction(optionsOrCallback) ? optionsOrCallback : callback;
  return {
    input,
    options,
    callback: cb
  };
}
function handle(params, executor) {
  const { input, options, callback } = parseFunctionOverloads(
    params.inputOrOptionsOrCallback,
    params.optionsOrCallback,
    params.callback
  );
  const executorWrapper = () => executor({
    input,
    options
  });
  if (callback) {
    return callbackify(executorWrapper)(callback);
  }
  return executorWrapper();
}
function handleGenerator(params, executor) {
  const { input, options, callback } = parseFunctionOverloads(
    params.inputOrOptionsOrCallback,
    params.optionsOrCallback,
    params.callback
  );
  const executorWrapper = () => executor({
    input,
    options
  });
  if (callback) {
    return callbackifyGenerator(executorWrapper)(callback);
  }
  return executorWrapper();
}
function isTypeOf(value, result) {
  return result;
}
function isNullish(value) {
  return value === null || value === void 0;
}
function callbackifyGenerator(generatorFn) {
  return (callback) => {
    (async () => {
      try {
        for await (const result of generatorFn()) {
          callback(null, result);
        }
      } catch (err) {
        callback(err);
      }
    })();
  };
}
function callbackifyStream(stream) {
  return (callbackFn) => {
    stream.on("data", (data) => callbackFn(null, data));
    stream.on("error", (err) => callbackFn(err));
    stream.on(
      "finish",
      () => callbackFn(null, null)
    );
  };
}
function callbackifyPromise(promise) {
  return (callbackFn) => {
    promise.then(
      (data) => callbackFn(null, data),
      (err) => callbackFn(err)
    );
  };
}
async function* paginator(executor, {
  offset = 0,
  count = Infinity,
  params,
  limit = 100
}) {
  let currentOffset = offset;
  let remainingCount = count;
  let totalCount = Infinity;
  while (currentOffset < totalCount) {
    const paginatedSearchParams = new URLSearchParams2(params);
    paginatedSearchParams.set("offset", currentOffset.toString());
    paginatedSearchParams.set(
      "limit",
      Math.min(remainingCount, limit).toString()
    );
    const output = await executor(paginatedSearchParams);
    for (const result of output.results) {
      yield result;
      if (--remainingCount === 0)
        return;
      ++currentOffset;
    }
    totalCount = output.totalCount;
  }
}
function isEmptyObject(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
async function asyncGeneratorToArray(generator) {
  const response = {
    chunks: [],
    output: void 0
  };
  while (true) {
    const { done, value } = await generator.next();
    if (done) {
      response.output = value;
      break;
    }
    response.chunks.push(value);
  }
  return response;
}

// src/utils/stream.ts
import { Readable } from "stream";
var TypedReadable = class extends Readable {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _read(size) {
  }
  addListener(event, listener) {
    return super.addListener(event, listener);
  }
  on(event, listener) {
    return super.on(event, listener);
  }
  [Symbol.asyncIterator]() {
    return super[Symbol.asyncIterator]();
  }
};

// src/helpers/config.ts
import os from "os";
import path from "path";
import fs from "fs";
import YAML from "yaml";
function lookupEndpoint() {
  return process.env.GENAI_ENDPOINT || "https://workbench-api.res.ibm.com";
}
function lookupApiKey() {
  if (process.env.GENAI_API_KEY) {
    return process.env.GENAI_API_KEY;
  }
  const credentialsPath = path.join(os.homedir(), ".genai", "credentials.yml");
  if (fs.existsSync(credentialsPath)) {
    try {
      const fileContent = fs.readFileSync(credentialsPath, "utf8");
      return YAML.parse(fileContent).apiKey;
    } catch (err) {
      console.warn("Failed to read credentials");
    }
  }
  return null;
}

// src/client/cache.ts
var CacheDiscriminator = {
  GENERATE_CONFIG: "generate-config",
  TUNE: "tune",
  PROMPT_TEMPLATE: "prompt-template",
  FILE: "file",
  MODEL: "model",
  MODELS: "models"
};
function generateCacheKey(discriminator, id = "") {
  return `${discriminator}#${id}`;
}

// src/client/client.ts
var Client = class {
  #client;
  #options;
  constructor(config = {}) {
    const endpoint = config.endpoint ?? lookupEndpoint();
    if (!endpoint) {
      throw new InvalidInputError("Configuration endpoint is missing!");
    }
    const apiKey = config.apiKey ?? lookupApiKey();
    if (!apiKey) {
      throw new InvalidInputError("Configuration API key is missing!");
    }
    const agent = version ? `node-sdk/${version}` : "node-sdk";
    this.#options = {
      endpoint,
      apiKey,
      headers: {
        "User-Agent": agent,
        "X-Request-Origin": agent,
        ...config.headers,
        Accept: "application/json",
        Authorization: `Bearer ${apiKey}`
      },
      retries: config.retries ?? RETRY_ATTEMPTS_DEFAULT
    };
    this.#client = setupCache(
      axios.create({
        baseURL: this.#options.endpoint,
        headers: this.#options.headers,
        httpAgent: new http.Agent({ keepAlive: true }),
        httpsAgent: new https.Agent({ keepAlive: true }),
        maxRedirects: 0,
        transitional: {
          clarifyTimeoutError: true
        }
      })
    );
  }
  #fetcher(input, schema) {
    if (input.stream) {
      const outputStream = new TypedReadable({
        autoDestroy: true,
        objectMode: true,
        signal: input.signal
      });
      const onClose = () => {
        if (outputStream.readable) {
          outputStream.push(null);
        }
      };
      const delegatedController = new AbortController();
      if (input.signal) {
        input.signal.addEventListener(
          "abort",
          () => {
            delegatedController.abort();
          },
          {
            once: true
          }
        );
      }
      const onError = (e) => {
        const err = errorTransformer(e);
        delegatedController.abort();
        if (outputStream.readable) {
          outputStream.emit("error", err);
          throw err;
        }
        onClose();
      };
      const url = new URL(
        input.url ?? this.#options.endpoint,
        this.#options.endpoint
      );
      fetchEventSource(url.toString(), {
        method: "POST",
        body: JSON.stringify(input.data),
        headers: {
          ...this.#options.headers,
          "Content-Type": "application/json"
        },
        signal: delegatedController.signal,
        onclose: onClose,
        async onopen(response) {
          const contentType = response.headers.get("content-type") || "";
          if (response.ok && contentType === EventStreamContentType) {
            return;
          }
          const responseData = contentType.startsWith("application/json") ? await response.json().catch(() => null) : null;
          const headers = (() => {
            const obj = {};
            response.headers?.forEach((value, key) => {
              obj[key] = value;
            });
            return obj;
          })();
          onError(
            new HttpError(
              responseData?.message || "Invalid response from server",
              response.statusText,
              response.status,
              responseData?.extensions,
              responseData,
              headers
            )
          );
        },
        onmessage(message) {
          if (message.event === "close") {
            onClose();
            return;
          }
          if (message.data === "") {
            return;
          }
          const result = safeParseJson(message.data);
          if (result === null) {
            onError(
              new InternalError(
                `Failed to parse message "${JSON.stringify(message)}"`
              )
            );
            return;
          }
          outputStream.push(schema ? schema.parse(result) : result);
        },
        onerror: onError
      }).catch(() => {
      });
      return outputStream;
    }
    const { retries, retryCondition, cache, ...restConfig } = input;
    return promiseRetry(
      (retry, attempt) => this.#client({
        ...restConfig,
        timeout: input.timeout === void 0 || input.timeout === Infinity ? 0 : Math.max(1, input.timeout),
        cache: {
          ...cache,
          override: (cache ? cache.override : false) || attempt > 1
        }
      }).catch((err) => {
        const error = errorTransformer(err);
        const conditionFn = retryCondition ?? isRetrievableError;
        if (conditionFn(error)) {
          retry(error);
        }
        throw error;
      }),
      { retries: retries ?? this.#options.retries }
    ).then(({ data }) => schema ? schema.parse(data) : data);
  }
  tokenize({ input, ...restInput }, optionsOrCallback, callback) {
    return handle(
      {
        optionsOrCallback,
        callback
      },
      async ({ options }) => {
        const { results } = await this.#fetcher({
          ...options,
          method: "POST",
          url: "/v1/tokenize",
          data: {
            ...restInput,
            use_default: true,
            inputs: [input]
          },
          stream: false
        });
        if (results.length !== 1) {
          throw new InvalidInputError("Unexpected number of results");
        }
        return results[0];
      }
    );
  }
  generate(input, optionsOrCallback, callbackOrNothing) {
    const { callback, options } = parseFunctionOverloads(
      void 0,
      optionsOrCallback,
      callbackOrNothing
    );
    const getTimeout = (() => {
      const start = Date.now();
      const timeout = options?.timeout ?? this.#client.defaults.timeout;
      return () => Math.max(0, timeout ? timeout - (Date.now() - start) : Infinity);
    })();
    const inputs = !Array.isArray(input) ? [input] : input;
    const prepareRequest = ({
      input: inputText,
      ...params
    }) => ({
      ...options,
      method: "POST",
      url: "/v1/generate",
      data: {
        ...params,
        inputs: [inputText],
        use_default: !params.prompt_id,
        parameters: {
          ...params.parameters,
          stream: Boolean(options?.stream)
        }
      }
    });
    if (options?.stream) {
      if (inputs.length > 1) {
        throw new InvalidInputError(
          "Cannot do streaming for more than one input!"
        );
      }
      const stream = new Transform({
        autoDestroy: true,
        objectMode: true,
        transform(chunk, encoding, callback2) {
          try {
            const {
              generated_text = "",
              stop_reason = null,
              input_token_count = 0,
              generated_token_count = 0,
              ...props
            } = (chunk.results || [{}])[0];
            callback2(null, {
              generated_text,
              stop_reason,
              input_token_count,
              generated_token_count,
              ...chunk.moderation && {
                moderation: chunk.moderation
              },
              ...props
            });
          } catch (e) {
            const err = chunk || e;
            callback2(err, null);
          }
        }
      });
      this.#fetcher({
        ...prepareRequest(inputs[0]),
        timeout: getTimeout(),
        stream: true
      }).on("error", (err) => stream.emit("error", errorTransformer(err))).pipe(stream);
      if (!callback) {
        return stream;
      }
      callbackifyStream(stream)(callback);
      return;
    }
    const tokenCounts = inputs.map(() => 1);
    const promises = inputs.map(async (inputData, index, arr) => {
      try {
        while (getTimeout() > 0) {
          const limits = await this.generateLimits(void 0, {
            ...options,
            timeout: getTimeout()
          });
          const cumulativeTokenCount = tokenCounts.slice(0, index + 1).reduce((acc, value) => acc + value, 0);
          const isWithinLimits = limits.tokensUsed + cumulativeTokenCount <= limits.tokenCapacity;
          if (isWithinLimits) {
            try {
              const { results } = await this.#fetcher({
                ...prepareRequest(inputData),
                timeout: getTimeout()
              });
              if (results.length !== 1) {
                throw new InternalError("Unexpected number of results");
              }
              return results[0];
            } catch (err) {
              if (err instanceof HttpError && err.extensions?.code === "TOO_MANY_REQUESTS" && err.extensions?.reason === "CONCURRENCY_LIMIT") {
                continue;
              }
              throw err;
            }
          }
          await wait(Math.min(getTimeout(), 1e3));
        }
        throw new AxiosError("Timeout exceeded", AxiosError.ETIMEDOUT);
      } finally {
        tokenCounts[index] = 0;
        await Promise.allSettled(arr.slice(0, index));
      }
    });
    if (callback) {
      promises.forEach((promise) => callbackifyPromise(promise)(callback));
    } else {
      return Array.isArray(input) ? promises : promises[0];
    }
  }
  generateConfig(inputOrResetOptions, optionsOrCallback, callback) {
    return handle(
      {
        inputOrOptionsOrCallback: inputOrResetOptions,
        optionsOrCallback,
        callback
      },
      ({ input, options }) => {
        const cacheKey = generateCacheKey(CacheDiscriminator.GENERATE_CONFIG);
        if (isTypeOf(
          input,
          !input || "reset" in input
        )) {
          const { reset, ...httpOptions2 } = input ?? {};
          if (reset) {
            return this.#fetcher({
              ...httpOptions2,
              method: "DELETE",
              url: "/v1/generate/config",
              cache: {
                update: {
                  [cacheKey]: "delete"
                }
              }
            });
          } else {
            return this.#fetcher({
              ...httpOptions2,
              method: "GET",
              url: "/v1/generate/config",
              id: cacheKey
            });
          }
        }
        const { strategy, ...httpOptions } = options ?? {};
        return this.#fetcher({
          ...httpOptions,
          method: strategy === "merge" ? "PATCH" : "PUT",
          url: "/v1/generate/config",
          stream: false,
          data: input,
          cache: {
            update: {
              [cacheKey]: "delete"
            }
          }
        });
      }
    );
  }
  generateLimits(inputOrCallback, optionsOrCallback, callback) {
    return handle(
      {
        inputOrOptionsOrCallback: inputOrCallback,
        optionsOrCallback,
        callback
      },
      ({ options }) => this.#fetcher({
        ...options,
        method: "GET",
        url: "/v1/generate/limits",
        cache: {
          ttl: 1e3
        }
      })
    );
  }
  models(inputOrCallback, optionsOrCallback, callback) {
    return handle(
      {
        inputOrOptionsOrCallback: inputOrCallback,
        optionsOrCallback,
        callback
      },
      async ({ options }) => {
        const { results } = await this.#fetcher({
          ...options,
          method: "GET",
          url: "/v1/models",
          id: generateCacheKey(CacheDiscriminator.MODELS)
        });
        return results;
      }
    );
  }
  model(input, optionsOrCallback, callback) {
    return handle(
      {
        optionsOrCallback,
        callback
      },
      async ({ options }) => {
        const { results } = await this.#fetcher({
          ...options,
          method: "GET",
          url: `/v1/models/${encodeURIComponent(input.id)}`,
          id: generateCacheKey(CacheDiscriminator.MODEL, input.id)
        });
        return results;
      }
    );
  }
  tunes(inputOrCallback, optionsOrCallback, callback) {
    return handleGenerator(
      {
        inputOrOptionsOrCallback: inputOrCallback,
        optionsOrCallback,
        callback
      },
      ({ input, options }) => {
        const params = new URLSearchParams();
        if (input?.filters?.search)
          params.set("search", input.filters.search);
        if (input?.filters?.status)
          params.set("status", input.filters.status);
        return paginator(
          (paginatorParams) => this.#fetcher({
            ...options,
            method: "GET",
            url: `/v1/tunes?${paginatorParams.toString()}`,
            cache: false
          }),
          {
            offset: input?.filters?.offset ?? void 0,
            count: input?.filters?.count ?? void 0,
            params
          }
        );
      }
    );
  }
  tune(input, optionsOrCallback, callback) {
    return handle({ optionsOrCallback, callback }, async ({ options }) => {
      let apiOutput;
      const isTuneInput = isTypeOf(input, "id" in input);
      if (isTuneInput) {
        const cacheKey = generateCacheKey(CacheDiscriminator.TUNE, input.id);
        const opts = options;
        if (opts?.delete) {
          await this.#fetcher({
            ...options,
            method: "DELETE",
            url: `/v1/tunes/${encodeURIComponent(input.id)}`,
            cache: {
              update: {
                [cacheKey]: "delete",
                [generateCacheKey(CacheDiscriminator.MODEL, input.id)]: "delete",
                [generateCacheKey(CacheDiscriminator.MODELS)]: "delete"
              }
            }
          });
          return;
        } else {
          apiOutput = await this.#fetcher({
            ...options,
            method: "GET",
            url: `/v1/tunes/${encodeURIComponent(input.id)}`,
            id: cacheKey
          });
        }
      } else {
        apiOutput = await this.#fetcher({
          ...options,
          method: "POST",
          url: `/v1/tunes`,
          data: input,
          cache: {
            update: {
              [generateCacheKey(CacheDiscriminator.MODELS)]: "delete"
            }
          }
        });
      }
      const { status } = apiOutput.results;
      switch (status) {
        case "COMPLETED":
          return {
            ...apiOutput.results,
            status,
            downloadAsset: async (type) => this.#fetcher({
              ...options,
              responseType: "stream",
              method: "GET",
              url: `/v1/tunes/${encodeURIComponent(
                apiOutput.results.id
              )}/content/${type}`,
              cache: false
            })
          };
        default:
          return { ...apiOutput.results, status };
      }
    });
  }
  tuneMethods(inputOrCallback, optionsOrCallback, callback) {
    return handle(
      {
        optionsOrCallback,
        callback
      },
      async ({ options }) => {
        const { results } = await this.#fetcher({
          ...options,
          method: "GET",
          url: `/v1/tune_methods`
        });
        return results;
      }
    );
  }
  promptTemplate(input, optionsOrCallback, callback) {
    return handle({ optionsOrCallback, callback }, async ({ options }) => {
      const isCreateInput = isTypeOf(
        input,
        !("id" in input)
      );
      if (isCreateInput) {
        const { results: result2 } = await this.#fetcher(
          {
            ...options,
            method: "POST",
            url: `/v1/prompt_templates`,
            data: input
          },
          PromptTemplateOutputSchema
        );
        return result2;
      }
      const endpoint = `/v1/prompt_templates/${encodeURIComponent(input.id)}`;
      const cacheKey = generateCacheKey(
        CacheDiscriminator.PROMPT_TEMPLATE,
        input.id
      );
      const opts = options;
      if (opts?.delete) {
        await this.#fetcher({
          ...options,
          method: "DELETE",
          url: endpoint,
          cache: {
            update: {
              [cacheKey]: "delete"
            }
          }
        });
        return;
      }
      const { id: _, ...body } = input;
      if (isTypeOf(body, !isEmptyObject(body))) {
        const { results: result2 } = await this.#fetcher(
          {
            ...options,
            method: "PUT",
            url: endpoint,
            data: body,
            cache: {
              update: {
                [cacheKey]: "delete"
              }
            }
          },
          PromptTemplateOutputSchema
        );
        return result2;
      }
      const { results: result } = await this.#fetcher(
        {
          ...options,
          method: "GET",
          url: endpoint,
          id: cacheKey
        },
        PromptTemplateOutputSchema
      );
      return result;
    });
  }
  promptTemplates(inputOrCallback, optionsOrCallback, callback) {
    return handleGenerator(
      {
        inputOrOptionsOrCallback: inputOrCallback,
        optionsOrCallback,
        callback
      },
      ({ input, options }) => paginator(
        async (paginatorParams) => this.#fetcher(
          {
            ...options,
            method: "GET",
            url: `/v1/prompt_templates?${paginatorParams.toString()}`,
            cache: false
          },
          PromptTemplatesOutputSchema
        ),
        {
          offset: input?.offset ?? void 0,
          count: input?.count ?? void 0
        }
      )
    );
  }
  promptTemplateExecute(input, optionsOrCallback, callback) {
    return handle({ optionsOrCallback, callback }, async ({ options }) => {
      const { results } = await this.#fetcher({
        ...options,
        method: "POST",
        url: "/v1/prompt_templates/output",
        data: input
      });
      return results;
    });
  }
  history(inputOrCallback, optionsOrCallback, callback) {
    return handleGenerator(
      {
        inputOrOptionsOrCallback: inputOrCallback,
        optionsOrCallback,
        callback
      },
      ({ input, options }) => {
        const params = new URLSearchParams();
        if (input?.status)
          params.set("status", input.status);
        if (input?.origin)
          params.set("origin", input.origin);
        return paginator(
          (paginatorParams) => this.#fetcher(
            {
              ...options,
              method: "GET",
              url: `/v1/requests?${paginatorParams.toString()}`,
              cache: false
            },
            HistoryOutputSchema
          ),
          {
            offset: input?.offset ?? void 0,
            count: input?.count ?? void 0,
            params
          }
        );
      }
    );
  }
  files(inputOrCallback, optionsOrCallback, callback) {
    return handleGenerator(
      {
        inputOrOptionsOrCallback: inputOrCallback,
        optionsOrCallback,
        callback
      },
      ({ input, options }) => paginator(
        async (paginatorParams) => this.#fetcher(
          {
            ...options,
            method: "GET",
            url: `/v1/files?${paginatorParams.toString()}`,
            cache: false
          },
          FilesOutputSchema
        ),
        {
          offset: input?.offset ?? void 0,
          count: input?.count ?? void 0
        }
      )
    );
  }
  file(input, optionsOrCallback, callback) {
    return handle({ optionsOrCallback, callback }, async ({ options }) => {
      const transformOutput = (apiOutput) => ({
        ...apiOutput,
        download: () => this.#fetcher({
          ...options,
          responseType: "stream",
          method: "GET",
          url: `/v1/files/${encodeURIComponent(apiOutput.id)}/content`,
          cache: false
        })
      });
      const isCreateInput = isTypeOf(input, !("id" in input));
      if (isCreateInput) {
        const { purpose, filename, file } = input;
        const formData = new FormData();
        formData.append("purpose", purpose);
        formData.append("file", file, { filename });
        const { results: result2 } = await this.#fetcher(
          {
            ...options,
            method: "POST",
            url: `/v1/files`,
            data: formData
          },
          FileOutputSchema
        );
        return transformOutput(result2);
      }
      const endpoint = `/v1/files/${encodeURIComponent(input.id)}`;
      const cacheKey = generateCacheKey(CacheDiscriminator.FILE, input.id);
      const opts = options;
      if (opts?.delete) {
        await this.#fetcher({
          ...options,
          method: "DELETE",
          url: endpoint,
          cache: {
            update: {
              [cacheKey]: "delete"
            }
          }
        });
        return;
      }
      const { results: result } = await this.#fetcher(
        {
          ...options,
          method: "GET",
          url: endpoint,
          id: cacheKey
        },
        FileOutputSchema
      );
      return transformOutput(result);
    });
  }
  chat(input, optionsOrCallback, callback) {
    const { callback: cb, options } = parseFunctionOverloads(
      void 0,
      optionsOrCallback,
      callback
    );
    if (options?.stream) {
      const stream = new Transform({
        autoDestroy: true,
        objectMode: true,
        transform(chunk, encoding, callback2) {
          const { results, ...rest } = chunk;
          callback2(null, {
            ...rest,
            result: results[0]
          });
        }
      });
      this.#fetcher({
        ...options,
        method: "POST",
        url: "/v0/generate/chat",
        data: {
          ...input,
          parameters: {
            ...input.parameters,
            stream: true
          }
        },
        stream: true
      }).on("error", (err) => stream.emit("error", errorTransformer(err))).pipe(stream);
      if (cb) {
        callbackifyStream(stream)(cb);
        return;
      } else {
        return stream;
      }
    } else {
      const promise = (async () => {
        const { results, ...rest } = await this.#fetcher(
          {
            ...options,
            method: "POST",
            url: "/v0/generate/chat",
            data: input,
            stream: false
          },
          ChatOutputSchema
        );
        if (results.length !== 1) {
          throw new InternalError("Unexpected number of results");
        }
        return { ...rest, result: results[0] };
      })();
      if (cb) {
        callbackifyPromise(promise)(cb);
        return;
      } else {
        return promise;
      }
    }
  }
};

export {
  GenerateInputSchema,
  GenerateLimitsOutputSchema,
  GenerateConfigInputSchema,
  GenerateConfigOutputSchema,
  TokenizeInputSchema,
  TokenizeOutputSchema,
  ModelsOutputSchema,
  ModelOutputSchema,
  TuneStatusSchema,
  TuneInputSchema,
  TuneOutputSchema,
  TuneMethodsOutputSchema,
  PromptTemplateInputSchema,
  PromptTemplateCreateInputSchema,
  PromptTemplateUpdateInputSchema,
  PromptTemplateOutputSchema,
  PromptTemplatesOutputSchema,
  PromptTemplateExecuteInputSchema,
  PromptTemplateExecuteOutputSchema,
  HistoryStatusSchema,
  HistoryOriginSchema,
  HistoryInputSchema,
  HistoryOutputSchema,
  FilePurposeSchema,
  FileInputSchema,
  FileOutputSchema,
  FilesOutputSchema,
  ChatInputSchema,
  ChatOutputSchema,
  ChatStreamInputSchema,
  ChatStreamOutputSchema,
  api_types_exports,
  BaseError,
  InvalidInputError,
  InternalError,
  RequestError,
  RequestCanceledError,
  HttpError,
  errorTransformer,
  isRetrievableError,
  version,
  concatUnique,
  isNotEmptyArray,
  isNullish,
  asyncGeneratorToArray,
  RETRY_ATTEMPTS_DEFAULT,
  Client
};
